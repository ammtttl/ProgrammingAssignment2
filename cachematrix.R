## makeCacheMatrix takes a matrix as input, defines 4 functions and creates a list of the four functions: 
## set, get, setsolve, getsolve, and two data objects: x, m in the makeCacheMatrix environment to be passed to cacheSolve.
## makeCacheMatrix first initialise the object m that's used to store the inverse value and set x to the input value whenever it's called.
## Then 4 functions are defined to set pointers to the parent environment(makeCacheMatrix).
## Finally it creates a named list with the four objects so that it could later be called by $ sign.

## cacheSolve takes the list as input
## It calls getsolve function from the list to look for a value to assign to m.
## Since m is not defined in the getsolve function, it finds the value in the parent environment(makeCacheMatrix).
## If it's the first time makeCacheMatrix is called, m is initialised to NULL.
## Then when cacheSolve checks if m has been calculated before(is not null), result will be false and get function in the list will be called to get a matrix to calculate an inverse.
## Since x is not defined in the get function, it finds the value for x in the parent environment(makeCacheMatrix), which is the input matrix for makeCacheMatrix, and assign the value to data
## Data is then passed to the solve function to calculate an inverse to be assigned to m.
## Then the setsolve function is called from the list to take the input m and asign that to the object m defined in the parent environment (makeCacheMatrix) to be stored in memory.
## Finally cacheSolve returs the calculated m value.
## The next time cacheSolve is called, getsolve will return an m that's populated with the data calculated in the previous run.(is not null)
## The if statement returns true, so the message "getting cached data" is printed to console and a cached m value is returned.
## Set function could be called from the list to set a new matrix to calculate an inverse.
## It takes a new matrix y as input and assign it to x in the parent environment(makeCacheMatrix) to be retrieved by the next get call and initialise m, so the is not null check returns false and trigger the following process to calculate inverse.


## makeCacheMatrix creates a list of objects to be passed to cacheSolve

makeCacheMatrix <- function(x = matrix()) {
  m <- NULL
  set <- function(y) {
    x <<- y
    m <<- NULL
  }
  get <- function() x
  setsolve <- function(solve) m <<- solve
  getsolve <- function() m
  list(set = set, get = get,
       setsolve = setsolve,
       getsolve = getsolve)
}

## cacheSolve takes the list of objects generated by makeCacheMatrix. 
## It returns the cached value if it's for the same matrix(found in cache), or calculate the inverse when the matrix is different(not found in cache). 

cacheSolve <- function(x, ...) {
  m <- x$getsolve()
  if(!is.null(m)) {
    message("getting cached data")
    return(m)
  }
  data <- x$get()
  m <- solve(data, ...)
  x$setsolve(m)
  m
}
